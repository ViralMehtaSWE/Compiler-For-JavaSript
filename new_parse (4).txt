#include <stdio.h>
#include "lexer.h"
#define STACK_SIZE 1000
#define POP_ERROR_CODE 46
#define rules_size 46
int parseTable[][35] =
{
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},	
{0,1,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,46},
{0,2,47,47,47,47,46,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,46,47},
{0,47,47,47,47,47,3,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,4,45},
{0,47,47,47,47,47,5,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,46,47},
{0,47,47,45,47,47,47,47,6,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,7,47},
{0,47,47,46,47,47,47,47,8,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47},
{0,47,47,45,47,47,47,47,47,9,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,10,47},
{0,47,47,47,47,45,47,11,11,47,46,47,11,47,11,47,47,47,47,47,47,47,47,47,47,47,47,47,12,47},
{0,47,47,47,47,47,47,13,14,47,47,47,15,47,16,47,47,47,47,47,47,47,47,47,47,47,47,47,46,47},
{0,47,47,47,47,47,47,17,47,47,46,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47},
{0,47,47,47,47,47,47,47,18,47,46,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47},
{0,47,47,47,47,47,47,19,47,47,46,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47},
{0,47,47,47,47,47,47,47,47,20,45,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,21,47},
{0,47,47,47,47,47,47,46,46,47,47,47,22,47,46,47,47,47,47,47,47,47,47,47,47,47,47,47,46,47},
{0,47,47,47,47,47,47,47,47,47,47,47,23,46,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47},
{0,47,47,47,47,47,47,46,46,47,47,47,24,47,46,47,47,47,47,47,47,47,47,47,47,47,47,47,46,47},
{0,47,47,47,47,47,47,46,46,47,47,47,46,47,25,47,47,47,47,47,47,47,47,47,47,47,47,47,46,47},
{0,47,26,46,47,47,47,26,47,47,46,47,47,47,47,27,28,29,30,31,32,47,47,47,47,26,26,26,47,47},
{0,47,47,45,47,47,47,47,47,47,45,47,47,47,47,47,47,47,47,47,47,33,34,47,47,47,47,47,35,47},
{0,47,36,47,47,47,47,36,47,47,47,47,47,47,47,47,47,47,47,47,47,46,46,47,47,36,36,36,46,47},
{0,47,47,45,47,47,47,47,47,47,45,47,47,47,47,47,47,47,47,47,47,45,45,37,38,47,47,47,39,47},
{0,47,40,47,47,47,47,41,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,46,46,42,43,44,46,47},
{0,47,47,45,47,45,47,47,47,47,45,47,47,47,47,47,47,47,47,47,47,45,45,47,47,47,47,47,45,45} 
};

char terminals[100][100] = {"\0","main","(",")","{","}","function","id","var",",",";","=","if","else","while",
"&&","<","<=",">",">=","==","+","-","*","/","True","False","number","''","$"};

enum
{



	NIL = 0,
	MAIN = 1,
	LB =2,
	RB=3,
	LC=4,
	RC=5,
	FUNCTION =6,
	ID=7,
	VAR=8,
	COMMA=9,
	COLON=10,
	EQUAL = 11,
	IF=12,
	ELSE =13,
	WHILE =14,
	AND = 15,
	LESSTHAN =16,
	LESSEQUAL=17,
	GRET=18,
	GRETEQUAL=19,
	EQUALEQUAL=20,
	PLUS=21,
	MINUS=22,
	MULT=23,
	DIV=24,
	TRUE=25,
	FALSE=26,
	NUMBER=27,
	EMPTY=28,
	DOLLAR=29,

	P=-1,
	MF=-2,
	OFS=-3,
	OF=-4,
	AL=-5,
	B=-6,
	Z=-7,
	SS=-8,
	S=-9,
	AS=-10,
	DS=-11,
	C=-12,
	G=-13,
	IFS=-14,
	IFP=-15,
	IFELSES=-16,
	LS=-17,
	E=-18,
	EP=-19,
	T=-20,
	TP=-21,
	F=-22,
	X=-23

};

int rules[][10]=
{
	{},
	{MF ,OFS},
	{MAIN , LB , RB, LC , SS , RC },
	{OF , OFS},
	{X},
	{FUNCTION , ID , LB , AL , RB , LC , SS , RC},
	{B},
 	{X},
	{VAR , ID , Z},
	{COMMA ,B},
	{X},
	{S , SS},
	{X},
	{AS,COLON},
	{DS,COLON},
	{IFS},
	{LS},
	{ID, EQUAL ,E},
	{VAR, C},
	{ID , G},
	{COMMA , C},
	{X},
	{IFELSES},
	{IF ,LB , E, RB, LC,SS,RC},
	{IFP, ELSE,LC,SS,RC},
	{WHILE,LB,E,RB,LC,SS,RC},
	{T,EP},
	{AND,T,EP},
	{LESSTHAN,T,EP},
	{LESSEQUAL,T,EP},
	{GRET,T,EP},
	{GRETEQUAL,T,EP},
	{EQUALEQUAL,T,EP},
	{PLUS,T,EP},
	{MINUS,T,EP},
	{X},
	{F,TP},
	{MULT,F,TP},
	{DIV,F,TP},
	{X},
	{LB,E,RB},
	{ID},
	{TRUE},
	{FALSE},
	{NUMBER},
	{EMPTY}
};
int length[]={0,2,6,2,1,8,1,1,3,2,1,2,1,1,1,1,1,3,2,2,2,1,1,7,5,8,2,3,3,3,3,3,3,3,3,1,2,3,3,1,3,1,1,1,1,1};
int stk[10000];
int tp=-1;
void push(int val)
{
	stk[++tp]=val;
}
int pop_back()
{
	if(tp>=0) return stk[tp--];
	else return POP_ERROR_CODE;
}
int top()
{
	if(tp>=0) return stk[tp];
	else return POP_ERROR_CODE;
}
int is_terminal_symbol(int val)
{
	return(val>=1&&val<=29);
}
void print_stk()
{
	int i;
	printf("Printing stk ---->\n");
	for(i=0;i<=tp;i++)
	{
		printf("%d ",stk[i]);
	}
	printf("\n------------------------------------------\n");
}
void generate_error(){}
int main()
{
	initialize_lexer();
	int errors=0;
	int ctr=8;
	int flag=0;
	push(DOLLAR); push(P);
	printf("%d %d %d\n",stk[0],stk[1],tp);
	while(1)
	{
		int token=get_next_token();
		printf("token = %d\n",token);
		while(1)
		{
			if(is_terminal_symbol(top()))
			{
				if(token==top()) {int prev=pop_back();if(prev==DOLLAR) {flag=1;break;}}
				else {generate_error();errors++;printf("---------------------------->>>>>>>>>>>>token!=top(), token = %d, top() = %d\n",token,top());}
				break;
			}
			else
			{
				int idx=parseTable[-1*top()][token];
				printf("idx = %d, top() = %d, token = %d\n",idx,top(),token);
				if(idx>=rules_size){generate_error();errors++;printf(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>idx>rules_size\n");break;}
				int i;
				pop_back();
				for(i=length[idx]-1;i>=0;i--) if(rules[idx][i]!=EMPTY) push(rules[idx][i]);
			}
			print_stk();
		}
		print_stk();
		if(flag==1) {printf("Yeah!\n");break;}
	}
	if(errors==0&&flag==1) printf("Parse Successful!\n");
	else printf("Parsing Process Failed!\n");
}
